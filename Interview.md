# 面试知识点总结

## C++

- C++是否为面向对象语言，面向对象的的三个特性  
  
  C++是一门面向对象语言，面向对象的三个特性分别为封装，继承，多态。  
  封装体现为C++当中具有对象和类的概念，在类当中可以对一系列数据和方法进行封装，并且控制其他类对这些数据方法的访问权限。  
  继承可以使一个新的类使用现有类的所有功能，并实现功能的扩展。
  多态可以简单概括为一个接口，多种方法。具体表现为在不同继承关系的对象中去调用同一个函数，产生了不同的结果。这种机制主要通过虚函数来实现。

- 类的内存分布
  
  如果一个类带有虚函数，在这个类的开始位置会插入一个虚函数指针，如果这个类有继承的父类，父类会放在该派生类的前面。

- 虚函数是什么  
  
  虚函数通过vitual关键字进行声明，在进行虚函数的声明之后，一个父类指针能够去调用派生类中的相应函数。在没有虚函数时，基类指针只能够访问派生类的成员变量而不能访问派生类的成员函数。  
  例子：假如有一个英雄类，英雄类有两个派生类分别为战士类和法师类，英雄类中有一个攻击的虚函数，法师类和战士类分别对攻击函数进行了不同的实现，法师的攻击是火球术，战士的攻击是劈砍，这时初始化一个英雄类指针，使它分别指向法师和战士，并且调用攻击函数，因为虚函数的关系这个指针指向法师类时调用攻击函数会使用火球术，指向战士类时调用攻击函数会使用劈砍。  
  虚函数通过虚函数表进行实现，虚函数表中包含了所有虚函数的地址，虚函数按照声明顺序放在虚函数表中，如何在派生类中对父类的函数进行了重载，覆盖的函数将会放在虚函数表中原本父类虚函数的位置，这样在调用该函数时就会调用子类中重新实现的函数。当一个子类有多个父类时，每一个父类将会拥有一个不同的虚函数表。在子类的虚函数没有覆盖父类虚函数的场合，子类的虚函数将会放在第一个被声明的父类的虚函数表后面。

- 如果析构函数为虚函数会发生什么  
  
  C++中默认的析构函数不是虚函数，如果将默认的析构函数声明为虚函数，因为需要额外的虚函数指针以及虚函数表，将会占用内存。但是当该类成为父类时，析构函数需要被设置成虚函数。在将析构函数设置成虚函数之后，在释放指向派生类父类指针时，会调用派生类的析构函数。如果不设置为虚函数，在释放指针时派生类的析构函数无法被调用，则会造成内存泄漏。

- 重写和重载有什么区别  
  
  范围区别：重写和被重写的函数在不同的类中，重载和被重载的函数在同一类中。  
  参数区别：重写与被重写的函数参数列表一定相同，重载和被重载的函数参数列表一定不同。  
  virtual的区别：重写的基类必须要有virtual修饰，重载函数和被重载函数可以被virtual修饰，也可以没有。

- 智能指针是什么
  
  智能指针：智能指针是一个类，这个类的构造函数中传入一个普通指针，析构函数中释放传入的指针。智能指针的类都是栈上的对象，所以当函数结束时会自动被释放，方便管理堆内存。智能指针利用RAII（资源获取即初始化）技术堆普通指针进行封装，智能指针的实质是一个对象，行为表现像一个指针。  
  shared_ptr：基于引用计数的智能指针，可随意赋值，支持多个指针指向相同对象。每次拷贝都会使对象的引用计数加1，赋值使愿对象引用计数减1，新对象引用计数加1，当计数为0时，自动释放内存。  
  unique_ptr：唯一拥有所指对象。同一时刻智能有一个unique_ptr指向指定对象，禁止拷贝语义，只有移动语义。在出现异常的情况下，动态资源能得到释放。  
  weak_ptr：若引用，只引用不计数，没有重载operator*和->，对shared_ptr资源观测。针对shared_ptr的循环引用，两个指针内存都无法释放的问题需要手动打破循环引用或使用weak_ptr。  
  
- 强制类型转换

  static_cast：静态类型转换，在编译时决定转换的类型，用于代替旧的C风格类型转换。  
  dynamic_cast：子类和父类之间的多态类型转换，可以用于将父类指针转换为子类指针。  
  reinterpreter_cast：重新解释类型转换。用于不同类型之间的指针类型转换，不同于static_cast，static_cast用于基本类型之间的转换。  
  const_cast：用于去掉const属性转换。

- static关键字的作用

  1. 限制符号的作用域只在本程序文件内使用。
  2. 指定变量的存储位置。对于函数内的变量都是存放在栈内存区，函数结束时自动释放。static变量都是存放在数据区，只有程序结束时才会被释放，且只存有一份。不管函数被调用多少次，static语句只在第一次调用时执行。后面的调用都不执行也不初始化。
  3. 类的静态成员变量。属于类而不是类的某个实例对象，在类中只是声明，并不是定义，因此不分配内存，对类用sizeof求大小也不会将static变量得大小加入。必须在类声明的外部，以及main()函数的外部，也就是全部变量区域对类的static成员变量再次定义（定以后才分配唯一内存，此时该类静态成员变量相当于是全局的静态变量了，只是调用的时候要使用类名加::）。若只定义不赋值初始化，则默认初始化为0。
  4. 类的静态成员函数。只能调用本类的静态成员变量或函数，不能调用本类的非静态成员函数和变量。因为非静态成员函数和变量在类成员函数中调用时，都是由形参中隐含一个指向当前实例对象的this指针来调用。然而静态成员函数没有这个this形参。

- malloc和new的区别

- STL内存机制实现

- vector和list的优缺点

- map和unordered_map的不同
  
  map内部由红黑树实现，具有自动排序功能。红黑树的每一个节点表示map的一个元素，因此对map中元素的操作其实就是对红黑树元素的操作。使用中序遍历可以将元素从小到大进行遍历。由于红黑树的实现，map由较高的空间占用率。
  unordered_map内部由哈希表实现，内部元素无序，通过把key值映射到哈希表中的一个位置来进行访问，查找的时间复杂度可以达到O(1)。

## 排序算法

- 冒泡排序  
  
  比较相邻的元素。如果第一个比第二个大，就交换它们两个；  
  对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；  
  针对所有的元素重复以上的步骤，除了最后一个；  
  重复步骤1~3，直到排序完成。  

- 选择排序  
  
  初始状态：无序区为R[1..n]，有序区为空；
  第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；n-1趟结束，数组有序化了。

- 插入排序  
  
  从第一个元素开始，该元素可以认为已经被排序；
  取出下一个元素，在已经排序的元素序列中从后向前扫描；
  如果该元素（已排序）大于新元素，将该元素移到下一位置；
  重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；
  将新元素插入到该位置后；
  重复步骤2~5。

- 希尔排序  
  
  选择一个增量序列t1，t2，…，tk，其中ti>tj，tk=1；
  按增量序列个数k，对序列进行k 趟排序；
  每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。

- 归并排序  
  
  把长度为n的输入序列分成两个长度为n/2的子序列；
  对这两个子序列分别采用归并排序；
  将两个排序好的子序列合并成一个最终的排序序列。

  ```cpp
    void Merge(vector<int>& array, vector<int>& left, vector<int>& right){
        int length1 = left.size();
        int length2 = right.size();

        int i = 0, j = 0;

        while(i < length1 || j < length2){
            if(i >= length1){
                array.push_back(right[j++]);
            }else if(j >= length2){
                array.push_back(left[i++]);
            }else if(left[i] < right[j]){
                array.push_back(left[i++]);
            }else{
                array.push_back(right[j++]);
            }
        }
    }

    void MergeSort(vector<int>& array){
    int length = array.size();
    if(length <= 1){
        return;
    }
    vector<int> left;
    vector<int> right;

    for(int i = 0; i < length; i++){
        if(i < length / 2){
            left.push_back(array[i]);
        }else{
            right.push_back(array[i]);
        }
    }

    MergeSort(left);
    MergeSort(right);
    array.clear();
    Merge(array, left, right);
    }
  ```

- 快速排序  
  
  从数列中挑出一个元素，称为 “基准”（pivot）
  重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；
  递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。

  ```cpp
    void quick_sort(int s[], int l, int r)
    {
        if (l < r)
        {
            //Swap(s[l], s[(l + r) / 2]); //将中间的这个数和第一个数交换 参见注1
            int i = l, j = r, x = s[l];
            while (i < j)
            {
                while(i < j && s[j] >= x) // 从右向左找第一个小于x的数
                    j--;  
                if(i < j)
                    s[i++] = s[j];
                while(i < j && s[i] < x) // 从左向右找第一个大于等于x的数
                    i++;  
                if(i < j)
                    s[j--] = s[i];
            }
            s[i] = x;
            quick_sort(s, l, i - 1); // 递归调用
            quick_sort(s, i + 1, r);
        }
    }  
  ```

## 数据结构

- 链表

  - 如何判断链表成环
  - 每隔n个链表反转
  
    ```cpp
    /*
    * Definition for singly-linked list.
    * struct ListNode {
    *     int val;
    *     ListNode *next;
    *     ListNode(int x) : val(x), next(NULL) {}
    * };
    */
    class Solution {
    public:
        ListNode* reverseKGroup(ListNode* head, int k) {
            if(!head || !head -> next){
                return head;
            }
            ListNode* ptr, *nptr = NULL, *pptr = NULL;
            int size = 0;
            int count = 0;
            ptr = head;
            while(ptr){
                ptr = ptr -> next;
                size++;
            }
            if(size < k){
                return head;
            }
            ptr = head;
            while(ptr && count < k){
                nptr = ptr -> next;
                ptr -> next = pptr;
                pptr = ptr;
                ptr = nptr;
                count++;
            }
            if(nptr){
                head -> next = reverseKGroup(nptr, k);
            }
            return pptr;
        }
    };
    ```

- 树
- 图

## 图形学

- VAO，VBO分别是什么  
  VAO:顶点数组对象  
  VBO:顶点缓冲对象  
  VBO可以理解为一个缓冲容器，将需要渲染的顶点放在缓存中等待GPU去取用。VAO可以看作一个存放VBO的容器，VAO中存放着这次渲染需要使用的所有VBO的信息，VAO把VBO存放到特定位置，在需要时直接在这个位置取用VBO。  

- 渲染管线  
  3D坐标转换为2D坐标的处理过程。分为两个主要部分，第一部分为将3D坐标转变为2D坐标，第二部分为把2D坐标转变为    实际有颜色的像素。  
  渲染管线一共分为六个阶段，顶点着色器（可自定义），图元装配，几何着色器（可自定义），光栅化，片段着色器（可自定义），测试与混合。  
  顶点着色器是将一个单独顶点作为输入，把3D坐标转换为另一种3D坐标，同时顶点着色器允许对顶点属性进行一些基本处理。  
  图元装配是将顶点着色器输出的所有顶点作为输入，并将所有的点装配成制定图元的形状。  
  几何着色器将图元装配的输出的一系列顶点的集合作为输入，可以通过产生新的顶点构造出新的图元来生成其他形状。  
  几何着色器的输出会被传入光栅化阶段，这里会把图元映射为最终屏幕上相应的像素，生成共片段着色器使用的片段，在片段着色器运行之前会进行裁切，将视图以外的所有像素丢弃，以此来提升效率。  
  片段着色器会计算一个像素最终颜色，通常包含3D场景数据（光照，阴影等），这些数据可以被用来计算最终像素的颜色。  
  Alpha测试与混合会检测片段对应的深度值，用来判断这个像素是在其他物体前面还是后面，决定是否应该丢弃。该阶段也会检查alpha值，并对物体进行混合。  

- 坐标变换  
  从一个坐标系变换到另一个坐标系，需要用到几个变换矩阵，分别为模型矩阵，观察矩阵，投影矩阵  
  顶点起始于局部坐标，会依次变为世界坐标，观察坐标，裁剪坐标，直到屏幕坐标结束  
  模型矩阵记载了物体的位移，缩放，旋转信息，局部坐标通过与模型矩阵相乘来转换为世界坐标  
  观察矩阵模拟了从摄像机视角观察到的空间，通常由一系列位移和旋转的组合来进行完成，用来将世界坐标变换到观察坐标
  投影矩阵指定了一个范围的坐标，会将指定范围内的坐标变换为标准化坐标的范围，所有在范围外的坐标不会被映射射到-1.0到1.0的范围之内，会被裁剪掉。在这一阶段之后，最终的坐标将会被映射到屏幕空间中，并被转换成片段。  

- 深度缓冲  
  深度缓冲就像颜色缓冲一样，在每个片段中储存了信息，并且通常和颜色缓冲由一样的宽度和高度，深度缓冲是有窗口系统自动创建的，通常会以12，24或32位的float来存储它的深度值，大部分系统中，深度缓冲精度为24位  
  当深度测试被启用的时候，opengl会将一个片段的深度值与深度缓冲内容进行对比，如果测试通过了，深度缓冲会更新深度值，如果测试失败了，片段会被丢弃。  

- 模版测试  
  模版测试根据模版缓冲来进行，一个模版缓冲中，通常每个模版值都是8位，每个像素或者片段能够拥有256种不同的模版值。我们可以通过设定不同的模版值来选择保留或者抛弃这个片段。
  写入模版缓冲的大体步骤如下：
  1. 启用模版缓冲写入  
  2. 渲染物体，更新模版缓冲内容  
  3. 禁用模版缓冲写入  
  4. 渲染物体，这次根据模版缓冲的内容丢弃特定片段  

## 操作系统

- 堆和栈的区别
- 虚拟内存是什么
- 进程与线程的区别
- 进程间的通信方式
- 缓存系统如何实现
- 后台开发主要是做什么

## 网络

- TCP的3次握手与4次挥手
  
  - 握手
    第一次握手：客户端发送握手信号SYN=1和SEQ=x（随机产生的序列号）的数据包到服务器，服务器由SYN=1知道，客户端要求建立联机。  
    第二次握手：服务器收到请求后要求确认联机信息，向客户端发送SYN=1，ACK=x+1，以及随机产生的确认端序列号SEQ=y的包。  
    第三次握手：客户端收到后检查ACK是否正确，若正确，客户端会再发送ACK=y+1以及序列号SEQ=z，服务端收到后确认ACK值则连接建立成功。  
    完成三次握手之后客户端与服务器开始传送数据。

  - 为什么需要三次握手

  - 挥手

  - 为什么需要四次挥手

    

- TCP与UDP的区别
  